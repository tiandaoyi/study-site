import{_ as a,a as e,b as t,c as i}from"./chunks/network-tcpudp.65710dbe.js";import{_ as r,o as l,c as o,V as h}from"./chunks/framework.98960eec.js";const k=JSON.parse('{"title":"网络","description":"","frontmatter":{},"headers":[],"relativePath":"database/network.md","filePath":"database/network.md","lastUpdated":1684160613000}'),p={name:"database/network.md"},n=h('<h1 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h1><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><p><img src="'+a+'" alt="network-osi" title="network-osi"></p><h2 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h2><p>向用户提供应用服务时通信的活动</p><h3 id="http协议" tabindex="-1">HTTP协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;HTTP协议&quot;">​</a></h3><p>包括FTP、DNS、HTTP、SMTP、POP3等，主要解决如何包装数据，以及如何标识数据内容。</p><h2 id="传输层" tabindex="-1">传输层 <a class="header-anchor" href="#传输层" aria-label="Permalink to &quot;传输层&quot;">​</a></h2><p>提供处于网络连接中的两台计算机之间的数据传输</p><h3 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h3><p>提供可靠的字节流服务，采用三次握手建立一个连接。</p><h4 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h4><p><img src="'+e+'" alt="network-tcp1" title="network-tcp1"></p><p>目的：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</p><ol><li>客户端发送SYN报文到服务器端发起握手，发送完之后客户端处于SYN_SEND状态。</li><li>服务端收到SYN报文之后回复SYN和ACK报文给客户端</li><li>客户端收到SYN和ACK，向服务端发送一个ACK报文，客户端转为established状态，此时服务端收到ACK报文后也处于established状态，TCP连接建立成功。</li></ol><h4 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h4><p><img src="'+t+'" alt="network-tcp2" title="network-tcp2"></p><p>目的：断开连接</p><ol><li>客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT_1状态。</li><li>服务端收到FIN报文之后，会发送一个ACK报文，且把客户端的序列号+1作为ACK报文的序列号，此时服务端处于CLOSE_WAIT状态。</li><li>如果服务端也想断开连接了，和客户端的第一步一样，发送一个FIN报文给客户端。</li><li>客户端收到FIN报文之后，向服务端发送ACK报文，且把服务端的序列号+1作为自己ACK报文的序列号，此时客户端处于TIME_WAIT状态。</li></ol><p>服务端收到ACK报文之后，就处于关闭连接了，客户端等待了2MSL之后也会关闭连接。</p><h4 id="常见的tcp请求方法" tabindex="-1">常见的TCP请求方法 <a class="header-anchor" href="#常见的tcp请求方法" aria-label="Permalink to &quot;常见的TCP请求方法&quot;">​</a></h4><ol><li>GET：请求获取URL位置的资源</li><li>HEAD：请求获取URL位置资源的响应消息报告，即获得该资源的头部信息</li><li>POST：请求向URL位置的资源后附加新的数据</li><li>PUT：请求向URL位置存储一个资源，覆盖原URL位置的资源</li><li>PATCH：请求局部更新URL位置的资源，即改变该处资源的部分内容</li><li>DELETE：请求删除URL位置存储的资源</li></ol><h3 id="udp协议" tabindex="-1">UDP协议 <a class="header-anchor" href="#udp协议" aria-label="Permalink to &quot;UDP协议&quot;">​</a></h3><p>提供面向事务的简单不可靠信息传送服务，不需要建立连接。</p><h3 id="tcp和udp区别" tabindex="-1">TCP和UDP区别 <a class="header-anchor" href="#tcp和udp区别" aria-label="Permalink to &quot;TCP和UDP区别&quot;">​</a></h3><p><img src="'+i+'" alt="network-tcpudp" title="network-tcpudp"></p><h2 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h2><p>负责：处理网络上流动的数据包，规划数据通过网络中的路由和交换设备到达目标计算机。</p><p>工作：增加MAC地址转发给数据链路层，进行流量控制，拥塞控制等。</p><h3 id="ip协议" tabindex="-1">IP协议 <a class="header-anchor" href="#ip协议" aria-label="Permalink to &quot;IP协议&quot;">​</a></h3><p>负责把数据从一台计算机通过网络发送到另一台计算机，数据被分割成一小段一小段进行传输，每一段都包括发送端和接收端的IP地址。</p><h2 id="数据链路层" tabindex="-1">数据链路层 <a class="header-anchor" href="#数据链路层" aria-label="Permalink to &quot;数据链路层&quot;">​</a></h2><p>负责：处理网络层传下来的IP数据报，进一步划分成帧，并传输给物理层。</p><p>工作：进行CRC检测，差错控制等。</p><h2 id="物理层" tabindex="-1">物理层 <a class="header-anchor" href="#物理层" aria-label="Permalink to &quot;物理层&quot;">​</a></h2><p>负责：利用传输介质为数据链路层提供物理连接。</p><p>工作：定义物理设备如何传输数据。</p>',37),s=[n];function d(c,P,u,_,b,m){return l(),o("div",null,s)}const f=r(p,[["render",d]]);export{k as __pageData,f as default};
