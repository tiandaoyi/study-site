import{_ as e,o as i,c as l,S as o}from"./chunks/framework.6a244606.js";const t="/images/network-osi.png",r="/images/network-tcp1.png",h="/images/network-tcp2.jpg",n="/images/network-tcpudp.png",b=JSON.parse('{"title":"网络","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"fe/network.md","filePath":"fe/network.md","lastUpdated":1686047553000}'),s={name:"fe/network.md"};function d(p,a,c,u,T,P){return i(),l("div",null,a[0]||(a[0]=[o('<h1 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h1><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><p><img src="'+t+'" alt="network-osi" title="network-osi"></p><h2 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h2><p>向用户提供应用服务时通信的活动</p><h3 id="http协议" tabindex="-1">HTTP协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;HTTP协议&quot;">​</a></h3><p>包括FTP、DNS、HTTP、SMTP、POP3等，主要解决如何包装数据，以及如何标识数据内容。</p><h2 id="传输层" tabindex="-1">传输层 <a class="header-anchor" href="#传输层" aria-label="Permalink to &quot;传输层&quot;">​</a></h2><p>提供处于网络连接中的两台计算机之间的数据传输</p><h3 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h3><p>提供可靠的字节流服务，采用三次握手建立一个连接。</p><h4 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h4><p><img src="'+r+'" alt="network-tcp1" title="network-tcp1"></p><p>目的：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</p><ol><li>客户端发送SYN报文到服务器端发起握手，发送完之后客户端处于SYN_SEND状态。</li><li>服务端收到SYN报文之后回复SYN和ACK报文给客户端</li><li>客户端收到SYN和ACK，向服务端发送一个ACK报文，客户端转为established状态，此时服务端收到ACK报文后也处于established状态，TCP连接建立成功。</li></ol><h4 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h4><p><img src="'+h+'" alt="network-tcp2" title="network-tcp2"></p><p>目的：断开连接</p><ol><li>客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT_1状态。</li><li>服务端收到FIN报文之后，会发送一个ACK报文，且把客户端的序列号+1作为ACK报文的序列号，此时服务端处于CLOSE_WAIT状态。</li><li>如果服务端也想断开连接了，和客户端的第一步一样，发送一个FIN报文给客户端。</li><li>客户端收到FIN报文之后，向服务端发送ACK报文，且把服务端的序列号+1作为自己ACK报文的序列号，此时客户端处于TIME_WAIT状态。</li></ol><p>服务端收到ACK报文之后，就处于关闭连接了，客户端等待了2MSL之后也会关闭连接。</p><h4 id="常见的tcp请求方法" tabindex="-1">常见的TCP请求方法 <a class="header-anchor" href="#常见的tcp请求方法" aria-label="Permalink to &quot;常见的TCP请求方法&quot;">​</a></h4><ol><li>GET：请求获取URL位置的资源</li><li>HEAD：请求获取URL位置资源的响应消息报告，即获得该资源的头部信息</li><li>POST：请求向URL位置的资源后附加新的数据</li><li>PUT：请求向URL位置存储一个资源，覆盖原URL位置的资源</li><li>PATCH：请求局部更新URL位置的资源，即改变该处资源的部分内容</li><li>DELETE：请求删除URL位置存储的资源</li></ol><h3 id="udp协议" tabindex="-1">UDP协议 <a class="header-anchor" href="#udp协议" aria-label="Permalink to &quot;UDP协议&quot;">​</a></h3><p>提供面向事务的简单不可靠信息传送服务，不需要建立连接。</p><h3 id="tcp和udp区别" tabindex="-1">TCP和UDP区别 <a class="header-anchor" href="#tcp和udp区别" aria-label="Permalink to &quot;TCP和UDP区别&quot;">​</a></h3><p><img src="'+n+'" alt="network-tcpudp" title="network-tcpudp"></p><h2 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h2><p>负责：处理网络上流动的数据包，规划数据通过网络中的路由和交换设备到达目标计算机。</p><p>工作：增加MAC地址转发给数据链路层，进行流量控制，拥塞控制等。</p><h3 id="ip协议" tabindex="-1">IP协议 <a class="header-anchor" href="#ip协议" aria-label="Permalink to &quot;IP协议&quot;">​</a></h3><p>负责把数据从一台计算机通过网络发送到另一台计算机，数据被分割成一小段一小段进行传输，每一段都包括发送端和接收端的IP地址。</p><h2 id="数据链路层" tabindex="-1">数据链路层 <a class="header-anchor" href="#数据链路层" aria-label="Permalink to &quot;数据链路层&quot;">​</a></h2><p>负责：处理网络层传下来的IP数据报，进一步划分成帧，并传输给物理层。</p><p>工作：进行CRC检测，差错控制等。</p><h2 id="物理层" tabindex="-1">物理层 <a class="header-anchor" href="#物理层" aria-label="Permalink to &quot;物理层&quot;">​</a></h2><p>负责：利用传输介质为数据链路层提供物理连接。</p><p>工作：定义物理设备如何传输数据。</p><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h2><h3 id="_301-moved-permanently" tabindex="-1">301 Moved Permanently <a class="header-anchor" href="#_301-moved-permanently" aria-label="Permalink to &quot;301 Moved Permanently&quot;">​</a></h3><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><h3 id="_302-found" tabindex="-1">302 Found <a class="header-anchor" href="#_302-found" aria-label="Permalink to &quot;302 Found&quot;">​</a></h3><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p><h3 id="_303-see-other" tabindex="-1">303 See Other <a class="header-anchor" href="#_303-see-other" aria-label="Permalink to &quot;303 See Other&quot;">​</a></h3><p>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</p><h3 id="_304-not-modified" tabindex="-1">304 Not Modified <a class="header-anchor" href="#_304-not-modified" aria-label="Permalink to &quot;304 Not Modified&quot;">​</a></h3><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><h3 id="_307" tabindex="-1">307 <a class="header-anchor" href="#_307" aria-label="Permalink to &quot;307&quot;">​</a></h3><p>临时性重定向，与302类似，POST请求时不会从POST变成GET。</p><h3 id="_400-bad-request" tabindex="-1">400 Bad Request <a class="header-anchor" href="#_400-bad-request" aria-label="Permalink to &quot;400 Bad Request&quot;">​</a></h3><p>请求报文语法错误。</p><h3 id="_401-unauthorized" tabindex="-1">401 Unauthorized <a class="header-anchor" href="#_401-unauthorized" aria-label="Permalink to &quot;401 Unauthorized&quot;">​</a></h3><p>需要通过HTTP认证（BASIC认证、DIGEST认证）的认证信息，如果第一次请求401，则表示认证</p><p>响应一个WWW-Authenticate首部用以质询用户信息，用来第一次请求的对话窗口。</p><h3 id="_403-forbidden" tabindex="-1">403 Forbidden <a class="header-anchor" href="#_403-forbidden" aria-label="Permalink to &quot;403 Forbidden&quot;">​</a></h3><p>请求被拒绝，可以在实体的主体部分对原因进行描述。（权限相关比较多）</p><h3 id="_404-not-found" tabindex="-1">404 Not Found <a class="header-anchor" href="#_404-not-found" aria-label="Permalink to &quot;404 Not Found&quot;">​</a></h3><p>服务器上没有请求的资源。</p><h3 id="_500-502-internal-server-error" tabindex="-1">500/502 Internal Server Error <a class="header-anchor" href="#_500-502-internal-server-error" aria-label="Permalink to &quot;500/502 Internal Server Error&quot;">​</a></h3><p>服务器执行请求时发生了错误。</p><h3 id="_503-service-unavailable" tabindex="-1">503 Service Unavailable <a class="header-anchor" href="#_503-service-unavailable" aria-label="Permalink to &quot;503 Service Unavailable&quot;">​</a></h3><p>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h3 id="_504-gateway-timeout" tabindex="-1">504 Gateway Timeout <a class="header-anchor" href="#_504-gateway-timeout" aria-label="Permalink to &quot;504 Gateway Timeout&quot;">​</a></h3><p>充当网关或代理的服务器，未及时从远端服务器获取请求。（服务器繁忙/超时）</p><h2 id="服务器" tabindex="-1">服务器 <a class="header-anchor" href="#服务器" aria-label="Permalink to &quot;服务器&quot;">​</a></h2><h3 id="代理" tabindex="-1">代理 <a class="header-anchor" href="#代理" aria-label="Permalink to &quot;代理&quot;">​</a></h3><ul><li><p>中间人：是一种有转发功能的应用程序，请求或者响应时追加写入Via首部信息</p></li><li><p>缓存代理：转发响应时先将资源的副本存在代理服务器上，再收到相同资源时，可以不从源服务器哪里获取资源（缓存有效期）</p></li><li><p>透明代理：请求或者响应不做任何加工</p></li></ul><h3 id="网关" tabindex="-1">网关 <a class="header-anchor" href="#网关" aria-label="Permalink to &quot;网关&quot;">​</a></h3><p>可以转发服务器通信数据的服务器</p><p>可以将非HTTP请求转化为其他协议通信</p><p>可以提供通信的安全性（通信线路加密、连接数据库或者使用sql）</p><h3 id="隧道" tabindex="-1">隧道 <a class="header-anchor" href="#隧道" aria-label="Permalink to &quot;隧道&quot;">​</a></h3><p>在相隔很远的客户端和服务器两者之间进行中转，保持双方通信连接的应用程序</p><p>可以按要求建立一条与其他服务器的通信线路，使用SSL等加密手段进行通信（远距离的安全通信）</p><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><h3 id="响应头相关字段" tabindex="-1">响应头相关字段 <a class="header-anchor" href="#响应头相关字段" aria-label="Permalink to &quot;响应头相关字段&quot;">​</a></h3><p>Expires, Cache-Control, Last-Modified, ETag</p><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h3><p>浏览器第一次请求资源时，会将资源的副本保存再本地缓存中。</p><p>浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status code: 200 OK</p><h4 id="cache-control-http1-1头字段-高优先级" tabindex="-1">Cache-Control（http1.1头字段，高优先级） <a class="header-anchor" href="#cache-control-http1-1头字段-高优先级" aria-label="Permalink to &quot;Cache-Control（http1.1头字段，高优先级）&quot;">​</a></h4><p>当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器时间）的5分钟内再次请求则直接读取缓存，不再请求。</p><ul><li><p>max-age=0时，每次都会请求服务器</p></li><li><p>s-maxage=300时，与max-age一样，但是仅适用于共享缓存（比如CDN）</p></li><li><p>public，响应会被缓存，并且在多用户间共享（默认）</p></li><li><p>private，响应只能作为私有缓存，不能再用户间共享</p></li><li><p>no-cache，强制发起请求，如果变更则返回新内容，否则返回304，读取缓存。</p></li><li><p>no-store，禁止一切缓存，不缓存请求或响应的任何内容。</p></li></ul><h4 id="expires-http1-0头字段" tabindex="-1">Expires（http1.0头字段） <a class="header-anchor" href="#expires-http1-0头字段" aria-label="Permalink to &quot;Expires（http1.0头字段）&quot;">​</a></h4><p>过期时间，如果设置了时间，则会在设置的时间内读取缓存，不再请求（缺点：客户端时间可能与服务器时间不一致）</p><h4 id="强缓存的disk与memory" tabindex="-1">强缓存的disk与memory <a class="header-anchor" href="#强缓存的disk与memory" aria-label="Permalink to &quot;强缓存的disk与memory&quot;">​</a></h4><ul><li>form memory cache</li></ul><p>不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在。</p><ul><li>form disk cache</li></ul><p>不访问服务器，一般已经加载过该资源且缓存在了硬盘当中，直接从硬盘中读取缓存。浏览器关闭后，数据依然存在。</p><p>优先访问memory cache，如果没有则访问disk cache。最后时请求网络资源</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>协商缓存是缓存失效时，浏览器向服务器发送请求，服务器根据请求request header的一些参数来判断是否命中协商缓存，如果命中，则返回304并带上新的response header通知浏览器从缓存中读取资源。</p><h4 id="etag-if-none-match-http1-1-优先级高-时间精度更小" tabindex="-1">ETag/If-None-Match(http1.1，优先级高，时间精度更小) <a class="header-anchor" href="#etag-if-none-match-http1-1-优先级高-时间精度更小" aria-label="Permalink to &quot;ETag/If-None-Match(http1.1，优先级高，时间精度更小)&quot;">​</a></h4><p>ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，ETag就会重新生成，（大小和时间的hash值）。</p><p>If-None-Match是当资源过期时，发现响应头有ETag，则再次向服务器发送请求时带上头If-None-Match，表示请求时间。服务器收到请求后发现有头If-None-Match则与被请求资源的唯一标识进行对比，若ETag没有改变，则返回304，浏览器从缓存中读取资源。</p><h4 id="last-modified-if-modified-since-http1-0" tabindex="-1">Last-Modified/If-Modified-Since(http1.0) <a class="header-anchor" href="#last-modified-if-modified-since-http1-0" aria-label="Permalink to &quot;Last-Modified/If-Modified-Since(http1.0)&quot;">​</a></h4><p>Last-Modified是浏览器向服务器发送请求时，服务器返回的响应头，表示该资源在服务器上的最后修改时间。</p><p>If-Modified-Since是当资源过期时（浏览器判断Cache-Control的max-age过期），发现响应头有Last-Modified，则再次向服务器发送请求时带上If-Modified-Since，表示请求时间。服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行对比，若最后修改时间较新，则返回新的资源和状态码200，否则返回304，浏览器从缓存中读取资源。</p><h3 id="缓存流程" tabindex="-1">缓存流程 <a class="header-anchor" href="#缓存流程" aria-label="Permalink to &quot;缓存流程&quot;">​</a></h3><ol><li>先判断强缓存，Cache-Control（优先级高）/Expires。</li><li>如果没有命中强缓存，再判断协商缓存，ETag（优先级高）和Last-Modified。</li></ol><h2 id="http与https" tabindex="-1">HTTP与HTTPS <a class="header-anchor" href="#http与https" aria-label="Permalink to &quot;HTTP与HTTPS&quot;">​</a></h2><h3 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h3><ol><li>无需证书</li><li>http是超文本传输协议，信息是明文传输</li><li>端口80</li><li>连接无状态</li><li>OSI网络模型中，HTTP协议工作在应用层</li></ol><h3 id="https" tabindex="-1">https <a class="header-anchor" href="#https" aria-label="Permalink to &quot;https&quot;">​</a></h3><ol><li>需要申请CA证书</li><li>https则是具有安全性的SSL加密传输协议。</li><li>端口443</li><li>连接有状态，协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li><li>OSI网络模型中，HTTPS安全传输机制在传输层</li></ol><h3 id="ssl-tls" tabindex="-1">SSL/TLS <a class="header-anchor" href="#ssl-tls" aria-label="Permalink to &quot;SSL/TLS&quot;">​</a></h3><p>SSL（Secure Sockets Layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议。</p><p>TLS（Transport Layer Security，传输层安全）是SSL的升级版，两者差别不大。</p><h4 id="ssl-tls通信过程" tabindex="-1">SSL/TLS通信过程 <a class="header-anchor" href="#ssl-tls通信过程" aria-label="Permalink to &quot;SSL/TLS通信过程&quot;">​</a></h4><p>SSL通信前会先进行TCP三次握手，建立连接</p><ol><li>客户端发送ClientHello：SSL握手开始时，客户端向服务器发送一个包含支持的SSL/TLS版本、加密算法、压缩算法等信息的ClientHello消息。</li><li>服务器发送ServerHello：服务器从收到的客户端信息中选择一个匹配的加密套件和其他参数，并发送ServerHello消息回复客户端。</li><li>服务器发送证书（可选）：如果服务器要求客户端进行身份验证，服务器会发送包含数字证书的Certificate消息。数字证书通常包含服务器的公钥。</li><li>客户端验证证书（可选）：如果服务器发送了数字证书，客户端会对证书进行验证，包括检查证书的有效性、签名和合法性等。如果验证失败，通信可能会被中止。</li><li>客户端生成密钥：客户端生成一个用于对称加密的随机密钥（session key），并使用服务器的公钥对其进行加密，然后将加密后的密钥发送给服务器。</li><li>服务器解密密钥：服务器使用自己的私钥解密客户端发送的加密密钥，获得对称加密的会话密钥。</li><li>握手完成：服务器和客户端都已经生成了会话密钥，握手过程结束，后续的数据传输将使用该会话密钥进行对称加密。</li><li>数据传输：之后，服务器和客户端之间的通信将使用会话密钥进行对称加密和解密，以保护数据的机密性和完整性。（由于非对称加密慢，所以使用非对称加密协商好然后使用对称加密进行数据传输）</li></ol><h2 id="基于http的协议" tabindex="-1">基于HTTP的协议 <a class="header-anchor" href="#基于http的协议" aria-label="Permalink to &quot;基于HTTP的协议&quot;">​</a></h2><h3 id="spdy" tabindex="-1">SPDY <a class="header-anchor" href="#spdy" aria-label="Permalink to &quot;SPDY&quot;">​</a></h3><p>SPDY是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。</p><h4 id="设计" tabindex="-1">设计 <a class="header-anchor" href="#设计" aria-label="Permalink to &quot;设计&quot;">​</a></h4><ol><li>多路复用流（无限制处理多个HTTP请求，所有请求都在一条TCP连接上完成）</li><li>分配优先级</li><li>压缩HTTP头</li><li>推送服务器端资源</li><li>服务器提示客户端使用SPDY（避免发送不必要的请求）</li></ol><h3 id="http1-0" tabindex="-1">HTTP1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;HTTP1.0&quot;">​</a></h3><ol><li>无状态，每次请求都要携带所有信息</li><li>每次请求都要建立连接，完成后立即断开</li><li>只能传输文本</li><li>请求/响应头信息不够丰富</li><li>无法满足多媒体传输的需求</li></ol><h3 id="http1-1" tabindex="-1">HTTP1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;HTTP1.1&quot;">​</a></h3><ol><li>持久连接（Persistent Connection）：HTTP/1.1 默认启用持久连接，即在单个连接上可以发送多个请求和响应，减少了连接建立和断开的开销。而在 HTTP/1.0 中，每个请求和响应都需要单独建立和断开连接。</li><li>流水线（Pipelining）：HTTP/1.1 支持流水线请求，即在不等待响应的情况下连续发送多个请求。这样可以减少延迟，提高性能。HTTP/1.0 并没有官方支持流水线请求，但某些服务器和客户端可能支持这一特性。</li><li>增加了请求头信息、响应头信息、请求方法、状态码等、缓存处理、管道机制、分块传输、虚拟主机、Cookie、内容编码、Host头字段等。</li><li>缺点：队头阻塞（一个请求阻塞，后面的请求也要等待）</li><li>优化：域名分片（一个域名只能建立6个连接，可以使用多个域名，每个域名建立6个连接，这样就可以建立更多的连接了）</li></ol><h3 id="http2-0" tabindex="-1">HTTP2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;HTTP2.0&quot;">​</a></h3><ol><li>多路复用（Multiplexing）：HTTP/2引入了多路复用功能，允许同时在单个连接上发送多个请求和响应（并发）。相比之下，HTTP/1.1使用序列化请求和响应，每个请求需要等待前一个请求的响应完成后才能发送，这导致了头阻塞（Head-of-Line Blocking）问题。</li><li>二进制分帧（Binary Framing）：HTTP/2使用二进制分帧层，将请求和响应消息分割为更小的帧，并进行二进制编码。这样可以更有效地传输数据，并提高性能。</li><li>首部压缩（Header Compression）：HTTP/2使用HPACK算法对首部字段进行压缩，减少了传输的数据量。相比之下，HTTP/1.1的首部字段在每个请求和响应中都会重复传输，增加了网络负载和延迟。</li><li>服务器推送（Server Push）：HTTP/2支持服务器主动推送功能，服务器可以在客户端请求前主动将相关资源推送给客户端，从而减少了往返时间延迟。</li><li>流量控制（Flow Control）：HTTP/2引入了流量控制机制，通过动态分配流量资源，避免了高带宽的连接对低带宽连接的不公平竞争。</li><li>请求优先级（Request Prioritization）：HTTP/2允许指定请求的优先级，使得服务器可以优先处理重要的请求，提高用户体验。</li></ol><h3 id="http3-0" tabindex="-1">HTTP3.0 <a class="header-anchor" href="#http3-0" aria-label="Permalink to &quot;HTTP3.0&quot;">​</a></h3><p>如果说HTTP2是会话层的变化，HTTP3就是传输层的变化。HTTP3的底层是基于UDP的，可以通过QUIC协议来实现。</p><h4 id="quic" tabindex="-1">QUIC <a class="header-anchor" href="#quic" aria-label="Permalink to &quot;QUIC&quot;">​</a></h4><p>由传输层的TCP改成QUIC（QUIC 的意思是“Quick UDP Internet Connection”）</p><p>QUIC是基于UDP实现的，替代传输层的TCP，把TCP的特性全部重新实现了一遍，当多路复用时TCP层出现丢包，TCP会发生队头阻塞，QUIC协议可以意识到Stream的存在，把HTTP中的Stream概念下移到了QUIC中，也就解决了队头阻塞的可靠性问题。</p><h4 id="http3的特点" tabindex="-1">HTTP3的特点 <a class="header-anchor" href="#http3的特点" aria-label="Permalink to &quot;HTTP3的特点&quot;">​</a></h4><ol><li>基于 UDP：HTTP/3 使用了基于 UDP 的传输层协议 QUIC，与基于 TCP 的 HTTP/1.1 和 HTTP/2 相比，UDP 具有更低的延迟和更好的性能。UDP 的无连接特性可以减少连接建立和拆除的开销，同时允许更快地建立连接和传输数据。</li><li>多路复用：HTTP/3 仍然支持多路复用，可以在同一个连接上同时传输多个请求和响应。多路复用可以减少请求延迟，提高并发性和效率。</li><li>0-RTT 连接恢复：HTTP/3 支持 0-RTT（Zero Round Trip Time）连接恢复，允许客户端在重新连接时更快地恢复之前的连接状态，减少握手的时间和延迟。</li><li>拥塞控制和错误恢复：QUIC 协议内置了拥塞控制和错误恢复机制，与 TCP 的拥塞控制相比，QUIC 更加灵活和敏感，可以更好地适应网络状况的变化，提供更稳定和可靠的连接。</li><li>连接迁移：HTTP/3 具有连接迁移的能力，即在客户端和服务器之间切换网络接口（如从 Wi-Fi 切换到移动数据网络）时，可以保持连接的连续性，减少连接中断和重新建立连接的开销。</li><li>安全性：HTTP/3 默认使用加密，所有的数据都通过 TLS 加密传输，提供更高的安全性和隐私保护。</li></ol><h2 id="常见web攻击技术" tabindex="-1">常见web攻击技术 <a class="header-anchor" href="#常见web攻击技术" aria-label="Permalink to &quot;常见web攻击技术&quot;">​</a></h2><h3 id="xss攻击-跨站脚本攻击" tabindex="-1">xss攻击（跨站脚本攻击） <a class="header-anchor" href="#xss攻击-跨站脚本攻击" aria-label="Permalink to &quot;xss攻击（跨站脚本攻击）&quot;">​</a></h3><p>XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的安全漏洞，攻击者通过注入恶意脚本代码来执行恶意操作。</p><h4 id="常见的-xss-攻击方式" tabindex="-1">常见的 XSS 攻击方式 <a class="header-anchor" href="#常见的-xss-攻击方式" aria-label="Permalink to &quot;常见的 XSS 攻击方式&quot;">​</a></h4><ol><li>存储型 XSS：攻击者将恶意脚本代码存储在目标网站的数据库中，当其他用户访问包含该恶意代码的页面时，恶意代码会被执行。这种攻击方式通常针对具有用户交互功能的网站，如留言板、评论功能等。</li><li>反射型 XSS：攻击者构造一个包含恶意脚本代码的 URL，并将该 URL 发送给目标用户。当用户点击该 URL 时，恶意代码会被服务器接收并执行，进而导致攻击。这种攻击方式通常需要用户点击特定的恶意链接才能触发。</li><li>DOM 型 XSS：攻击者利用客户端 JavaScript 的解析过程中的漏洞来进行攻击，通过修改页面的 DOM 结构，实现恶意操作。这种攻击方式不会将恶意代码发送到服务器，而是直接在用户的浏览器中执行。</li><li>基于事件的 XSS：攻击者利用 HTML 页面中的事件触发机制来进行攻击，通过注入恶意事件处理程序来执行恶意操作。例如，通过修改一个链接的点击事件，当用户点击该链接时，恶意代码会被触发执行。</li><li>XSS 蠕虫：这是一种恶意脚本代码的变种，它能够自我复制并传播到其他用户，以便在更广泛的范围内进行攻击。蠕虫通常利用存储型或反射型 XSS 漏洞来传播自身。</li></ol><h4 id="防范-xss-攻击的常见措施" tabindex="-1">防范 XSS 攻击的常见措施 <a class="header-anchor" href="#防范-xss-攻击的常见措施" aria-label="Permalink to &quot;防范 XSS 攻击的常见措施&quot;">​</a></h4><ol><li>输入验证和过滤：对用户输入的数据进行验证和过滤，确保输入的数据不包含恶意代码。（重要）</li><li>输出编码：在将用户数据输出到网页上时，使用合适的编码方式，如 HTML 实体编码或 JavaScript 转义，以防止恶意代码被执行。（重要）</li><li>设置合适的 Content Security Policy（CSP）：CSP 可以限制网页中可执行的脚本来源，防止恶意代码的执行。（重要）</li><li>使用安全的开发框架和库：使用经过安全审计和更新的开发框架和库，这些工具通常提供了内置的安全防护措施。</li><li>定期进行安全审计：对网站进行定期的安全审计，发现并修复潜在的 XSS 漏洞。</li><li>对敏感数据进行适当保护：对于存储型 XSS 攻击，确保用户输入的敏感数据在存储时进行适当的加密和防护。</li></ol><h4 id="从前端应用角度防范xss攻击" tabindex="-1">从前端应用角度防范XSS攻击 <a class="header-anchor" href="#从前端应用角度防范xss攻击" aria-label="Permalink to &quot;从前端应用角度防范XSS攻击&quot;">​</a></h4><ol><li>url参数使用encodeURIComponent方法转义。</li><li>尽量不用innerHtml</li><li>使用特殊符号、标签转义符。</li><li>Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</li><li>Cookie设置Secure属性，只有在HTTPS连接中才会发送到服务器端，这样也能很好的防范 XSS 攻击。</li><li>限制Cookie的作用域(Domain)和路径(Path)，限制 Cookie 只能在特定的域名和路径下使用，防止攻击者通过设置恶意的 Cookie 来冒充用户。</li></ol><h3 id="csrf攻击-跨站请求伪造" tabindex="-1">CSRF攻击（跨站请求伪造） <a class="header-anchor" href="#csrf攻击-跨站请求伪造" aria-label="Permalink to &quot;CSRF攻击（跨站请求伪造）&quot;">​</a></h3><p>CSRF(Cross-SIte Request Forgery) 跨站请求伪造是一种常见的网络安全攻击，攻击者通过欺骗用户在已认证的网站上执行非意愿的操作。</p><h4 id="常见的csrf攻击方式" tabindex="-1">常见的CSRF攻击方式 <a class="header-anchor" href="#常见的csrf攻击方式" aria-label="Permalink to &quot;常见的CSRF攻击方式&quot;">​</a></h4><ol><li>图片引用攻击（Image Tag Attack）：攻击者在恶意网站中嵌入一个图片标签，并设置其 src 属性为目标网站上的敏感操作接口地址。当用户访问恶意网站时，浏览器会自动发送一个请求到目标网站执行该敏感操作，因为浏览器会自动携带目标网站的身份凭证。</li><li>表单提交攻击（Form Submit Attack）：攻击者在恶意网站中创建一个表单，并设置表单的 action 属性为目标网站上的敏感操作接口地址。通过各种方式（如诱使用户点击、自动提交等），攻击者让用户提交表单，浏览器会自动发送请求到目标网站执行敏感操作。</li><li>链接跳转攻击（Link Hijacking）：攻击者在恶意网站中创建一个链接，并将链接指向目标网站上的敏感操作接口地址。通过各种方式（如诱使用户点击、自动跳转等），攻击者让用户点击该链接，浏览器会自动发送请求到目标网站执行敏感操作。</li><li>AJAX 请求攻击：攻击者通过 JavaScript 发起 AJAX 请求，将目标网站的敏感操作接口地址作为请求的目标，然后通过各种方式（如隐藏的 iframe、动态创建的表单等）将请求发送到目标网站。这种攻击方式通常会绕过同源策略，因此对目标网站的防护较为困难。</li><li>Flash 嵌入攻击：攻击者利用 Flash 中的漏洞或功能，通过在恶意 Flash 应用程序中嵌入目标网站上的敏感操作请求，然后将该 Flash 应用程序放置在恶意网站上。当用户访问恶意网站时，Flash 应用程序会自动发送请求到目标网站执行敏感操作。</li></ol><h4 id="csrf攻击防范措施" tabindex="-1">CSRF攻击防范措施 <a class="header-anchor" href="#csrf攻击防范措施" aria-label="Permalink to &quot;CSRF攻击防范措施&quot;">​</a></h4><ol><li>随机令牌（Token）：在用户进行敏感操作时，为每个操作生成一个随机令牌，并将该令牌嵌入到表单或请求参数中。服务器在接收到请求时，验证令牌的有效性。攻击者无法获取到合法用户的令牌，因此无法构造有效的请求。</li><li>SameSite Cookie 属性：将 Cookie 的 SameSite 属性设置为 Strict 或 Lax。Strict 模式下完全禁止跨域发送 Cookie，Lax 模式只允许在顶级导航时发送 Cookie。这样可以限制跨域请求中的 Cookie 发送，防止被滥用。</li><li>Referer 验证：服务器可以检查请求的 Referer 头部，判断请求的来源是否合法。如果请求的 Referer 不是同一域下的页面，服务器可以拒绝执行该请求。</li><li>双重提交 Cookie 验证：将一个 Cookie 值存储在用户的 Cookie 中，同时将其作为参数添加到表单中。服务器在接收到请求时，会验证 Cookie 中的值与表单中的值是否一致，以确定请求的合法性。</li><li>自定义请求头验证：服务器可以要求请求中包含自定义的请求头，例如 &quot;X-Requested-With&quot; 或 &quot;X-CSRF-Token&quot;。攻击者无法通过简单的 HTML 表单来构造包含这些自定义请求头的请求。</li><li>检查请求方法：服务器可以对敏感操作只接受 POST 请求进行处理，因为大多数 CSRF 攻击利用的是 GET 请求。</li><li>登录验证机制：要求用户在执行敏感操作之前进行身份验证，例如输入密码、提供二次验证等。这可以防止攻击者通过 CSRF 攻击直接执行敏感操作。</li><li>使用验证码：对于一些特别敏感的操作，可以要求用户输入验证码进行验证，以确保操作是由真实用户发起的。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>XSS和CSRF总结:</strong></p><p>XSS攻击是通过注入恶意脚本来实现，攻击者能够执行恶意操作，如窃取用户信息、篡改页面内容等。（攻击者留言板）</p><p>而CSRF攻击则是利用受害者在其他网站上的有效身份凭证，以伪装的形式发送请求来执行非预期操作。（用户访问恶意页面，自动向原来的发送了一个请求，比如一个恶意评论）</p></div><h2 id="cdn静态资源加载优化的方法" tabindex="-1">cdn静态资源加载优化的方法 <a class="header-anchor" href="#cdn静态资源加载优化的方法" aria-label="Permalink to &quot;cdn静态资源加载优化的方法&quot;">​</a></h2><p>CDN（内容分发网络）是一种用于加速网站和应用程序的技术，通过将静态内容缓存在离用户更近的边缘节点上，从而提供更快的加载速度和更好的用户体验。</p><ol><li>选择合适的 CDN 提供商：选择可靠且具有全球分布的 CDN 提供商，以确保资源能够快速且可靠地分发到用户。</li><li>合理设置缓存策略：通过设置适当的缓存头（例如 Cache-Control 和 Expires）来指定资源的缓存时间。这样可以减少对源服务器的请求，提高资源的加载速度。</li><li>启用压缩：在 CDN 配置中启用资源的压缩（例如 Gzip 压缩），以减少资源的传输大小，加快加载速度。</li><li>启用浏览器缓存：利用浏览器缓存来存储静态资源，使得用户在后续访问时可以从本地缓存中加载资源，减少网络请求。</li><li>使用持久化连接：在 CDN 配置中启用持久化连接（Keep-Alive），以减少建立和关闭连接的开销，提高资源的加载效率。</li><li>使用域名切片（Domain Sharding）：将静态资源分散到多个子域名上，使浏览器可以并行下载资源，从而提高加载速度。但请注意过度切片可能导致反效果，因为每个子域名都会增加 DNS 解析和连接建立的开销。</li><li>使用内容版本化（Content Versioning）：在资源的 URL 中添加版本号或哈希值，当资源发生更新时，可以通过修改 URL 来避免浏览器使用缓存的旧版本。</li><li>使用预加载和预解析：通过使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code> 标签来指示浏览器预先加载或预解析静态资源，从而加快资源的加载速度。</li><li>优化图片资源：对图片进行适当的压缩和优化，可以使用适合的图像格式、调整图像尺寸和质量，以减少图像文件的大小和加载时间。</li><li>使用 HTTP/2：如果你的 CDN 支持 HTTP/2，可以充分利用其多路复用、服务器推送等功能，提高资源的加载效率。</li></ol><h2 id="get和post请求的区别" tabindex="-1">get和post请求的区别 <a class="header-anchor" href="#get和post请求的区别" aria-label="Permalink to &quot;get和post请求的区别&quot;">​</a></h2><ol><li>GET在浏览器会退不会再次请求，而POST会再次请求</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有</li><li>GET参数通过URL传递，POST放在Request body中</li><li>GET参数暴露在地址栏不安全，POST放在报文内部更安全</li><li>GET一般用于查询信息，POST一般用于提交某种信息进行修改操作</li><li>GET产生一个TCP数据包，POST可能产生两个TCP数据包（数据过大，分为请求头和请求体发送过去）</li></ol><h2 id="cookie、session、token" tabindex="-1">cookie、session、token <a class="header-anchor" href="#cookie、session、token" aria-label="Permalink to &quot;cookie、session、token&quot;">​</a></h2><p>Cookie、Session和Token是常用于身份认证和状态管理的概念。</p><h3 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h3><p>Cookie是由服务器发送给浏览器的小型数据片段，存储在浏览器的本地文件中。它通常用于在客户端存储和传递有关用户的信息，例如用户的身份认证状态、会话标识符等。浏览器在每次请求中都会将相关的Cookie信息附加到请求头中发送给服务器。Cookie可以设置过期时间，可以由服务器端进行读取和写入。</p><h3 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h3><p>Session是一种服务器端的存储机制，用于在服务器端保存用户的会话数据。当用户首次访问服务器时，服务器会为其创建一个唯一的会话标识符（Session ID），并将该标识符存储在服务器上。在后续的请求中，浏览器会将该Session ID作为Cookie或URL参数发送给服务器，服务器通过Session ID来标识和管理用户的会话状态。会话数据存储在服务器上，可以存储更多的用户信息，而不受浏览器存储容量的限制。</p><h3 id="token" tabindex="-1">Token <a class="header-anchor" href="#token" aria-label="Permalink to &quot;Token&quot;">​</a></h3><p>Token是一种轻量级的身份认证机制，用于验证用户身份和授权访问。通常，当用户成功登录后，服务器会生成一个Token，并将其返回给客户端。客户端将Token保存起来，例如存储在本地存储（如LocalStorage）中。每次客户端向服务器发送请求时，都需要将Token作为请求的一部分发送给服务器进行验证。服务器验证Token的有效性，并根据Token中的信息进行相应的操作。Token通常包含加密的用户信息，避免了服务器端存储会话数据的需求，使得系统更易于扩展和维护。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>Cookie是在浏览器端存储数据的机制，用于在客户端和服务器之间传递信息。</li><li>Session是在服务器端存储用户会话数据的机制，通过会话标识符进行管理。</li><li>Token是一种轻量级的身份认证机制，通过加密的令牌进行身份验证和授权访问。</li></ul></div><p>这些机制在实际应用中经常结合使用，例如，服务器使用Session来管理用户的会话状态，而将Session ID存储在Cookie中传递给客户端。另外，Token也可以存储在Cookie中，或者通过其他方式（如请求头）发送给服务器。选择使用哪种机制取决于应用的需求和设计。</p>',160)]))}const k=e(s,[["render",d]]);export{b as __pageData,k as default};
