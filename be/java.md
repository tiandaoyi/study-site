# 计算机基础

## 任意进制转十进制
系数（每一位上的数）*基数（当前进制数）的权（从右往左0,1,2...）次幂 相加

## 十进制转任意进制
不断的除以基数，取余数，直到商为0，再将余数倒着拼起来

## 计算机光学颜色（红、绿、蓝）
10进制：0-255（可以理解数字越大颜色数越多）
16进制：0-FF（FF=15*16^0+15*16^1=255）

# java基础

## 基本数据类型

- 双引号是字符串，单引号是字符且只可有一个
- null类型不能直接打印
- 制表符 '/t': 把前面的字符串补齐到8，或者8的整数倍，最少补1个，最多补8个字符
- 整数类型int，浮点类型double

基本数据类型分为四类八种

整数：byte(-128~127)1字节, short(32768~32767)2字节, int默认(-2147483648~212147483647)3字节, long(19位数范围，后面加一个L)4字节
浮点数：float（后面需要加F后缀）, double（默认、范围更大）
字符：char（0-65535）
布尔：boolean

### java中不同进制的表现形式

- 0b开头二进制
- 0开头八进制
- 0x开头十六进制

## 方法

### 键盘录入

- nextDouble接受小数
- next接受字符串（制表符和空格分开计算）
- nextLine接受字符串（只有回车才表示结束）

```java
import java.util.Scanner;
public class ScannerDemo {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int num = sc.nextInt();
    System.out.println(num);
  }
}
```

### 随机数

```java
import java.util.Random;
Random r = new Random();
// 随机数的范围， 如果是100，则范围0-99
int number = r.nextInt();
```

## 目录结构

项目、模块、包、类

## 运算

### 算术运算

1. 整数参与计算，结果只能是整数
2. 小数参与计算，结果可能是不精确的

`10 / 3 = 3`
`10.0 / 3 = 3.33333335`

### 隐式转换（类型提升）

1. 小变大，取值范围小的转成取值范围大的，会把小的先改成大的，再进行运算
2. byte short char 三种类型数据进行运算的时候，都会先提升成int，再进行运算

```java
int a = 10
double = b = a // b = 10.0
```

### 强制转换

大的转小的

```java
int a1 = 300
byte a2 = (byte)a1 
```

### 有字符时的算术运算符

1. 从左向右加
2. 如果是字符串，会把之前的拼接到一起
3. 如果是char类型会使用asc码表的值进行计算

### 逻辑运算符

1. 逻辑与 `&`
2. 逻辑或 `|`
3. 逻辑异或 `^` 相同false，不同true
4. 逻辑非 `!` 取反
5. 短路与 `&&` 有短路效果
6. 短路或 `||` 有短路效果

### 三元运算符

- 格式： `关系表达式 ? 表达式1 : 表达式2`
- 特点：三元运算符的结果必须要使用，比如赋值给变量或者打印

### switch语句

1. 取值：byte,short,int, char, 枚举, String
2. case不允许重复
3. case的值只能是字面量，不允许是变量
4. jdk12特性，`case 变量 -> 执行语句`，可以省略`break;`
5. jdk12特性，如果有结果，可以把switch返回给一个变量
6. case如果没有break可以穿透
7. 可以case多个，用`,`分割 `case: 1,2,3,4`

## 数组

数组指的是一种容器，可以存储同种数据的多个值

- 数组容器在存储数据的时候，需要结合隐式转换考虑
- int类型的数组容器(byte, short, int)
- double类型的数组容器(byte, short, int, long, float, double)
- 建议容器的类型和存储的数据类型保持一致

两种格式

1. 数据类型[] 数组名（常用）
2. 数据类型 数组名[]

数组创建完毕，长度不变

初始化

```java
int[] array = new int[]{11,22,33}
// 简写
String[] arr1 = {"zhangsan", "lisi"}
```

索引，直接用[]，通过对应数组索引的下标获取数据 `arr1[0]`

定义数组（动态初始化创建）：
数据类型[] 数组名 = new 数据类型[数组的长度]
String[] arr = new String[50]
数组默认初始化值: 有规律的，跟类型有关 如0/0.0/false/\u0000(字符类型，空格)/null(引用类型)
动态初始化，明确数组长度。
静态初始化，手动指定元素，系统计算长度。

### 二维数组的格式

```java
int[][] arr = new int[][];
int[][] arr = {{1,2,3},{4,5,6}};
int[][] arr = new int[][]{{},{}};
```

## java内存分配

栈（方法运行时使用的内存）、堆（对象、数组，new出来的关键字都是在堆空间）、方法区（存储可以运行的class文件）、本地方法栈（jvm使用）、寄存器（cpu使用）

## 方法定义

`public static void 方法名(int num1, int num2){}`

### 方法的注意事项

方法不调用就不执行
方法与方法之间是平级关系，不能互相嵌套
方法的编写顺序和执行顺序无关
方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写return，后面不能跟具体的数据。

### 方法的重载

在同一个类中，方法名相同，参数不同的方法。与返回值无关
java虚拟机会通过参数的不同来区分同名的方法（参数不同构成重载，但不建议）

### 构造方法

1. 方法名与类名相同，大小写也有

```java
public class Student {
  // 空参构造方法
  public Student() {}

  // 有参构造方法
  public Student(int a, int b) {}
}
```

### JavaBean类

1. 类名需要见名知意
2. 成员变量使用private修饰
3. 提供至少两个构造方法（无参，有参）
4. 成员方法（提供每一个成员变量对应的setXxx()/getXxx()、如果还有其他行为，也需要写上）

快捷键alt+insert或者ptg插件（vscode）

### System.out.printf

第一部分参数：要输入的内容%s(占位)
第二部分参数：填充的数据

`System.out.printf("你好啊%s", "张三");`

## 字符串

String, StringBuilder, StringJonier, String Buffer, Pattern, Matcher

创建String对象的两种方式

1. 直接赋值 （记录的是串池里面的地址值）
2. new关键字记录的是堆里面的地址值）

```java
char[] chs = {'a', 'b', 'c', 'd'};
new String(chs);
```

字符串转数字

- 先转成字符，再-48 (ASC码表)

字符串比较

- 基本数据类型比较的是具体的值，引用类型比较的是具体的值
- 通常使用equals(), equalsIgnoreCase()来进行比较字符串中的内容 s1.equals(s2)

其他常见的字符串方法：substring(), replace(), chatAt(), toCharArray()

### StringBuilder

可以看成是一个容器，创建之后的内容是可变的，提高操作效率。

常见方法：append、reverse、length、toString

### StringJoiner

第一个参数是分隔符，第二个参数和第三个参数是开始结束符号（jdk8）

add length toString 方法

### 字符串相关原理

字符串存储原理

1. 直接赋值会复用字符串常量池中的
2. new出来不会复用，而是开辟一个新的空间

==号比较的是什么？

1. 基本数据类型比较数据值
2. 引用数据类型比较地址值

字符串拼接的底层原理

1. 如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。
2. 如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存

StringBuilder提高效率原理

- 所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存

StringBuilder源码分析

1. 初始化16长度字节数组
2. 添加的内容大于16会扩容成原来的容量*2 + 2
3. 扩容后还不够，以实际长度为准

## 集合

集合长度可变，只能存储引用类型，或者包装类

ArrayList这个类在底层做了一些处理，打印对象不是地址值，而是集合中存储数据内容。

成员方法: add, remove, set, get, size

```java
ArrayList<String> list = new ArrayList<>();
```

基本数据类型的包装类, char -> Character, int -> Integer，其他的都是首字母变成大写

## static

表示静态，是java中的一个修饰符，可以修饰成员方法，成员变量

随着类的加载而加载

### 静态变量

特点：

- 被该类所有对象共享。
- 不属于对象，属于类。
- 随着类的加载而加载，优先于对象存在。

调用方式

```java
// 类名去调用（推荐）
ClassXX.xx = "xx";
// 对象名调用
ClassXX myClass = new ClassXX();
myClass.xx = "xx";
```

### 静态方法

被static修饰的成员方法，叫做静态方法

特点：

- 多用在测试类和工具类中
- javabean类中很少会用

调用方式：

类名调用（推荐）
对象名调用

1. 静态方法中，只能访问静态。
2. 非静态方法可以访问所有
3. 静态方法中没有this关键字

### 工具类

帮主我们做一些事情的，但是不描述任何事物的类

1. 类名见名知义
2. 私有化构造方法
3. 方法定义为静态

### 继承

特点：

1. 只支持单继承，不支持多继承，但支持多层继承。
2. 每一个类都直接或者间接的继承Object
3. 子类只能访问父类中非私有的成员
4. 私有的（在构造方法，成员变量，成员方法中），只有成员变量能被子类继承，但需要通过其他方式使用

方法：子类继承父类过程中，非private\static\final都不会被继承（虚方法表）

#### 方法重写

@Override 重写注释


重写的注意事项：

1. 方法名，形参列表，必须与父类中的一致。
2. 子类重写父类方法时，访问权限必须大于等于父类
3. 子类重写父类方法时，返回值类型子类必须小于等于父类
4. 建议：重写的方法尽量和父类保持一致。
5. 只有被添加到虚方法表中的方法才能被重写

#### 继承构造方法：

1. 父类中的构造方法不会被子类继承。
2. 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。
3. 子类的构造方法第一行默认都是super()，不写也存在，如果想调用有参构造，必须手动写super。

this, super访问成员方法和成员变量直接this.，如果是访问构造方法，就this(...)

## 多态

什么是多态?

- 对象的多种形态

多态的前提？

1. 有继承/实现关系
2. 有父类引用指向子类对象
3. 有方法的重写

调用成员变量的特点：编译看左边，运行看左边
调用成员方法的特点：编译看左边，运行看右边

```java
Animal a = new Dog();
sout(a.name)  // animal  编译看左边
a.show() // this is dog  运行看右边（运行是看子类中重写的方法）
```

多态的弊端：

- 不能调用子类的特有方法

```java
Animal a = new Dog();
a.dogMethod(); // 报错

// 解决：编译回子类类型
Dog d = (Dog) a;
d.dogMethod();

// 推荐使用 instanceof 判断

if (a instanceOf Dog) {
Dog d = (Dog) a;
d.dogMethod();
}

if (a instanceOf Dog d) { // jdk 14
d.dogMethod();
}
```

- 使用父类型作为参数，可以接受所有子类对象，体现多态的扩展性与便利

## 类

全类名：包名+类名

规则

- 使用同一个包中的类时，不需要导包
- 使用java.lang包中的类时，不需要导包
- 其他情况都需要导包
- 如果同时使用两个包中的同名类，需要用全类名

## final

方法：不能被重写
类：不能被继承
变量：常量，只能被赋值一次

## 权限修饰符

private -> 空着不写 -> protected -> public
同一个类 -> 同一个包中其他类 -> 不同包下的子类 -> 不同包下的无关类

## 代码块

局部代码块，构造代码块，静态代码块

### 局部代码块

作用：提前结束变量的生命周期（已淘汰）

### 构造代码块

作用：抽取构造方法中的重复代码（不够灵活）

1. 写在成员位置的代码块
2. 作用：可以把多个构造方法中重复的代码抽取出来
3. 执行时机：我们在创建本类对象的时候会先执行构造代码块再执行构造方法

### 静态代码块

作用：数据的初始化（重点）

格式: static{}
特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次。
使用场景：随着类的加载而加载，只执行一次。

## 抽象类和抽象方法

作用

- 抽取共性时，无法确定方法体，就把方法定义为抽象的。
- 强制让子类按照某种格式重写。
- 抽象方法所在的类，必须是抽象类。

格式

- 抽象类的定义格式`public abstract class 类名 {}`
- 抽象方法的定义格式`public abstract 返回值类型 方法名(参数列表);`

注意事项

- 抽象类不能实例化
- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
- 可以有构造方法
- 抽象类的子类（要么重写抽象类中的所有抽象方法，要么是抽象类）

## 接口

接口的定义和使用

- 接口用关键字interface来定义: `public interface 接口名{}`
- 接口不能实例化
- 接口和类之间是实现关系，通过implements关键字表示`public class 类名 implements 接口名 {}`
- 接口的子类（实现类）
  - 要么重写接口中的所有方法
  - 要么是抽象类

接口中成员的特点

- 成员变量
  - 只能是常量
  - 默认修饰符: public static final
- 构造方法：无
- 成员方法
  - jdk7以前只能是抽象方法
  - 默认修饰符: public abstract
  - jdk9可以定义私有方法。

有方法体的方法（jdk8）

- 格式：`public default void show(){}`
- 注意事项:（不能省略default，不强制重写，但如实现了多个接口，子类必须对该方法进行重写）

静态方法(jdk8)

- 格式：`publisc static 返回值类型 方法名(参数列表){}`
- 注意事项:（static不能省略，静态方法只能通过接口名调用，不能通过实现类名或者对象调用）
- 调用: `接口.方法名();`

私有方法(jdk9)

- 为本接口的方法提供服务
- 普通的私有方法: `private 返回值类型 方法名（参数列表）{}`
- 静态的私有方法：`private static返回值类型 方法名（参数列表）{}`

## 设计模式

适配器设计模式

- 当接口中抽象方法过多，但我只用部分，就可以用该模式
- 相当于在实现类和接口之间添加了第三者。

## 内部类

写在一个类里面的类就叫内部类。

- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

jdk16之前，成员内部类里面不能定义静态变量

成员内部类：

- 当内部类被private修饰时，外部类调用内部类（Object多态或者直接使用对象）`Object ph = new People().getHeartInstancen();`
- 当内部类被非private修饰时，外部类名.内部类名 对象名 = 外部类对象.内部类对象(`People.Heart ph = new People().new Heart()`)
- 外部类成员变量和内部类成员变量重名时，使用Outer.this.变量名访问

静态内部类：

- 特殊的成员内部类
- 创建：`Outer.Inter oi = new Outer.Inter()`
- 调用静态内部类中的方法: 
  - 静态方法`Outer.Inter.show()`
  - 非静态方法`new Outer.Inter().show()`

局部内部类

- 将内部类定义在方法中就叫局部内部类，类似方法中的局部变量。
- 外界是无法直接使用，需要在方法内部创建对象并使用。
- 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

匿名内部类

- 本质上就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。
- 格式 `new 类名或者接口名() {/*重写方法*/}` 
- 格式细节
  - 包含了继承或实现，方法重写，创建对象。
  - 整体就是一个类的子类对象或接口的实现类对象
- 使用场景：当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码。

## GUI

AWT包、Swing包

