---
outline: deep
---

# 算法

## 数据结构

### 常见的数据结构

1. 数组（Array）：连续存储相同类型的元素的数据结构，通过索引访问元素，支持快速随机访问。
2. 链表（Linked List）：由节点组成的数据结构，每个节点存储数据和指向下一个节点的引用，支持高效的插入和删除操作。
3. 栈（Stack）：后进先出（LIFO）的数据结构，只允许在栈顶进行插入和删除操作，常用于解决需要遵循"后进先出"顺序的问题。
4. 队列（Queue）：先进先出（FIFO）的数据结构，支持在队尾进行插入操作，在队头进行删除操作，常用于模拟排队、调度任务等场景。
5. 树（Tree）：由节点和边组成的非线性数据结构，每个节点可以有零个或多个子节点，常用于表示层次关系和组织结构。
6. 图（Graph）：由节点和边组成的非线性数据结构，节点之间的边可以是有向的或无向的，用于表示多对多的关系。
7. 哈希表（Hash Table）：根据键（Key）和值（Value）之间的映射关系来存储和访问数据的数据结构，通过哈希函数实现高效的插入和查找操作。
8. 堆（Heap）：一种特殊的树形数据结构，常用于实现优先队列，具有快速找到最大或最小元素的特点。
9. 图表（Matrix）：由行和列组成的二维数据结构，常用于表示矩阵和矩阵相关的运算。

### 栈

栈（Stack）：后进先出（LIFO）的数据结构，只允许在栈顶进行插入和删除操作，常用于解决需要遵循"后进先出"顺序的问题。

栈的实现有两种方式：数组和链表。

#### 数组实现

```js
class Stack {
  constructor() {
    this.items = [];
  }

  push(item) {
    this.items.push(item);
  }

  pop() {
    return this.items.pop();
  }

  peek() {
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}
```

#### 链表实现

```js
class Stack {
  constructor() {
    this.head = null;
    this.length = 0;
  }

  push(item) {
    const node = new Node(item);
    node.next = this.head;
    this.head = node;
    this.length++;
  }

  pop() {
    if (this.isEmpty()) {
      return null;
    }
    const node = this.head;
    this.head = node.next;
    this.length--;
    return node.value;
  }

  peek() {
    if (this.isEmpty()) {
      return null;
    }
    return this.head.value;
  }

  isEmpty() {
    return this.length === 0;
  }

  size() {
    return this.length;
  }

  clear() {
    this.head = null;
    this.length = 0;
  }
}
```

### 队列

队列（Queue）是一种常见的数据结构，它遵循先进先出（First-In-First-Out，FIFO）的原则。队列可以想象成排队等候的人群，新的元素在队列的尾部添加，而从队列的头部移除。

#### 常见的队列类型

1. 普通队列（Queue）：普通队列是最基本的队列形式，遵循先进先出（FIFO）原则。新元素被添加到队列的尾部，而从队列的头部移除元素。
2. 双端队列（Deque）：双端队列，也称为双向队列，是一种允许在队列的两端进行插入和删除操作的队列。这意味着可以在队列的头部和尾部都进行入队和出队操作。
3. 优先队列（Priority Queue）：优先队列是一种特殊的队列，其中每个元素都有与之相关联的优先级。在优先队列中，元素按照优先级进行排序，而不是按照插入顺序。出队操作将移除具有最高优先级的元素。
4. 循环队列（Circular Queue）：循环队列是一种特殊的队列，底层使用循环数组来实现。循环队列允许在队列的末尾插入元素，同时从队列的头部删除元素，使得队列的操作更高效。

### 数组

数组（Array）：连续存储相同类型的元素的数据结构，通过索引访问元素，支持快速随机访问。

### 双指针

它使用两个指针在数据结构（通常是数组或链表）中进行遍历、搜索或比较。这两个指针通常位于数据结构的不同位置，可以分别称为快指针（fast pointer）和慢指针（slow pointer）。

#### 双指针的应用场景

1. 数组遍历：通过设置两个指针，可以同时遍历数组的不同部分，例如从头部和尾部同时向中间遍历，或者在数组中查找满足特定条件的元素。
2. 链表操作：在链表中使用双指针可以解决多种问题，比如判断链表是否存在环、寻找链表的中间节点、反转链表等。
3. 滑动窗口问题：双指针可以用于解决滑动窗口类型的问题，其中窗口由两个指针定义，可以根据问题的要求进行移动和调整。
4. 二分查找：在有序数组中使用双指针可以进行二分查找的过程，通过比较指针所在位置的元素与目标值的大小，来缩小查找范围。

### 链表

链表（Linked List）：由节点组成的数据结构，每个节点存储数据和指向下一个节点的引用，支持高效的插入和删除操作。

#### 链表的分类

1. 移除
2. 添加
3. 翻转
4. 环形

### 哈希表

## 字符串

### 字符串匹配相关算法

#### 暴力匹配

#### BF算法(Brute Force)

#### BM算法(Boyer-Moore)

#### KMP算法(Knuth-Morris-Pratt)

#### sunday算法

## 二分查找

## 动态规划

一个规模比较大的问题通过若干规模较小的问题来得到

### 五步骤

1. 确定dp数组以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 背包问题

![algorithm-dp1](/images/algorithm-dp1.png "algorithm-dp1")

## 贪心算法

## 树

树（Tree）：由节点和边组成的非线性数据结构，每个节点可以有零个或多个子节点，常用于表示层次关系和组织结构。

### 遍历方式

1. 前序遍历： 根左右
2. 中序遍历： 左根右
3. 后序遍历： 左右根
4. 层序遍历

### 树的分类

#### 无数值的

1. 满二叉树
2. 完全二叉树

#### 有数值的

1. 二叉搜索树
2. 平衡二叉搜索树

## 递归

### 递归的三个要素

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

## 回溯

## 排序

### 归并排序

#### 归并的思想

先归（二分），再并

### 插入排序

### 快排

平均时间复杂度nlogn，最坏情况n^2

### 堆排序

不稳定排序，时间复杂度nlogn

#### 顺序存储二叉树

#### 堆是具有一下性质的完全二叉树

- 大顶堆：每个节点的值都 大于或等于 其左右孩子节点的值
- 小顶堆：每个节点的值都 小于或等于 其左右孩子节点的值
- 注：大顶堆与小顶堆，没有要求左右值的大小关系，升序使用大顶堆，降序使用小顶堆

##### 堆的特点

1. 第 n 个元素的 左子节点 为 2*n+1
2. 第 n 个元素的 右子节点 为 2*n+2
3. 第 n 个元素的 父节点 为 (n-1)/2，向下取整
4. 最后一个非叶子节点为 Math.floor(arr.length/2)-1，下面还有值就是非叶子

## 图

有向无环，转成线性的排序 就叫拓扑排序

## 位运算
